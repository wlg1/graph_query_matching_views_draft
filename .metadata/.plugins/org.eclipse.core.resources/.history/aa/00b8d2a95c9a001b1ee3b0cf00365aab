package views;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import com.google.common.util.concurrent.SimpleTimeLimiter;
import com.google.common.util.concurrent.UncheckedTimeoutException;

import answerGraph.HybAnsGraphBuilder;
import dao.BFLIndex;
import dao.DaoController;
import dao.MatArray;
import dao.Pool;
import dao.PoolEntry;
import evaluator.DagHomIEFltSim;
import global.Consts;
import global.Consts.AxisType;
import global.Consts.status_vals;
import global.Flags;
import graph.Digraph;
import graph.GraphNode;
import helper.LimitExceededException;
import helper.QueryEvalStat;
import helper.QueryEvalStats;
import helper.TimeTracker;
import prefilter.FilterBuilder;
import query.graph.QEdge;
import query.graph.QNode;
import query.graph.Query;
import query.graph.QueryDirectedCycle;
import query.graph.QueryParser;
import query.graph.TransitiveReduction;
import views.ansgraphExclViews3; 

public class getQueryAnsGrViews {

	Query query;
	ArrayList<Query> views;
	HashMap<String, Integer> l2iMap;
	String queryFileN, dataFileN, outFileN, viewFileN;
	ArrayList<ArrayList<GraphNode>> invLsts;
	FilterBuilder fb;
	BFLIndex bfl;
	TimeTracker tt;
	QueryEvalStats stats;
	Digraph g;

	public getQueryAnsGrViews(Query INquery, ArrayList<Query> INviews, FilterBuilder INfb, 
			BFLIndex INbfl) {

		query = INquery;
		views = INviews;
		fb = INfb;
		bfl = INbfl;

	}

	//Build answer graph of a query on a data graph
	public void run() throws LimitExceededException {
		tt = new TimeTracker();
		tt.Start();
		//FILTER set of views for query to decide which ones to use to
		ArrayList<Query> viewsOfQuery = new ArrayList<Query>();
		for (Query view : this.views) {
			if (checkHom(view, query)) {
				viewsOfQuery.add(view);
			}
		}
		viewsOfQueries.add(viewsOfQuery);
		
		// build answer graph of each query exclusively using its views

		ArrayList<Query> viewsOfQuery = viewsOfQueries.get(i);
		ansgraphExclViews viewCandNodes = new ansgraphExclViews(query, viewsOfQuery, qid_Ansgr);
		ArrayList<ArrayList<PoolEntry>> QcosNodeSets = viewCandNodes.getAnsGr();
		
//		ArrayList<MatArray> mCandLists = qryCandLsts.get(i);
//		HybAnsGraphBuilder2 agBuilder = new HybAnsGraphBuilder2(query, bfl, mCandLists, QcosNodeSets);
//		ArrayList<Pool> qryAnsGr = agBuilder.run();
		
		return qryAnsGr;
//		double ltm = tt.Stop() / 1000;
//		System.out.println("\nTotal time: " + ltm + "sec.");
//		System.exit(0);
	}
	
	private boolean checkHom(Query view, Query query) { 		//this is exhaustive, iterative
		//1. For each view node, get all query nodes with same labels 
		ArrayList<ArrayList<Integer>> nodeMatch = new ArrayList<ArrayList<Integer>>();
		for (int i = 0; i < view.V; i++) {
			  ArrayList<Integer> vMatches = new ArrayList<Integer>(); 
			  for (int j = 0; j < query.V; j++) {
				  //check if same label as query
				  if (view.nodes[i].lb == query.nodes[j].lb) {
					  vMatches.add(query.nodes[j].id);
				  }
			  }  //end check qry candmatches for viewnode i
			  if (vMatches.isEmpty()) {
				return false; //at least 1 viewnode has no candmatches	
			  }
			  nodeMatch.add(vMatches); 
		} // end checking candmatches for all view nodes

		// 2. Convert query into graph and get Closure
		TransitiveReduction tr = new TransitiveReduction(query);
		AxisType[][] Qclosure = tr.pathMatrix;  // by comparing closure to compare to orig.edges, see that closure's new edges are desc edges, and doesn't change child edges
		
		//3. Given a node mapping h: for each view child edge, check if (h(x), h(y)) is a child edge
		// Try an initial mapping. 
		int[] candHom = new int[nodeMatch.size()]; 
		for (int i = 0; i < nodeMatch.size(); i++) {
			candHom[i] = nodeMatch.get(i).get(0);
		}
		
		//NOTE: ENSURE that 2 view nodes don't map to same query node. If they do, try next mapping.
		
		//keep row and col pointers on which match to change in candHom for next mapping.
		//if fail, move the col pointer right. if col pointer > col size, set cols of all rows below row pointer 
		//to 0 and move row pointer up (-1) and its col pointer right. then, set row pointer back to lowest row
		int rowChangeNext = nodeMatch.size() - 1;  //row pointer
		int colChangeToNext = 0; //col pointer
		
		while (true) {
			for (QEdge edge : view.edges) {
				String vEdgeType = edge.axis.toString();
				int viewHnode = edge.from; //head node of view
				int viewTnode = edge.to; //tail node of view
				int qryHnode = candHom[viewHnode]; // h(head node)
				int qryTnode = candHom[viewTnode]; // h(tail node)
				String qEdgeType = Qclosure[qryHnode][qryTnode].toString();
				
				if (!vEdgeType.equals(qEdgeType)) {
					//mapping failed,  so try another
					++colChangeToNext;
					
					//make sure there is next match for curr col. if not, go to row above to move it right
					if (colChangeToNext > nodeMatch.get(rowChangeNext).size() - 1) {
						while (colChangeToNext > nodeMatch.get(rowChangeNext).size() - 1){
							//move row pointer up (-1) and its col pointer right
							--rowChangeNext;
							
							if (rowChangeNext < 0) {
								return false; //'all mappings tried'
							}
							
							//get curr col pointer of new row pointer
							colChangeToNext = nodeMatch.get(rowChangeNext).indexOf(candHom[rowChangeNext]);
							++colChangeToNext;
							
							//check if col has another match to the right
							if (colChangeToNext <= nodeMatch.get(rowChangeNext).size() - 1) {
								
								//set cols of all rows below row pointer to 0. only do this if -1 to row pointer
								for (int i = nodeMatch.size() - 1; i > rowChangeNext; i--) {
									candHom[i] = nodeMatch.get(i).get(0);
								} //end for: reseting col indices
								
								candHom[rowChangeNext]= nodeMatch.get(rowChangeNext).get(colChangeToNext);
								rowChangeNext = nodeMatch.size() - 1; //reset col pointer and row pointer
								colChangeToNext = 0; 
							} // end if: check col has another match to the right
						} //end while: checking if col reached end
						
					} else {
						candHom[rowChangeNext]= nodeMatch.get(rowChangeNext).get(colChangeToNext);
					}
					break; //break out 'end of check each edge' and try new candHom mapping
				} //end if (!vEdgeType.equals(qEdgeType)): check edge consistency
			} // end for (QEdge edge : view.edges): check each edge consistency
			// Found mapping with all edges consistent -> use view for query, add to list of query's views
			return true; //all edges passed, so use this mapping
		} // end of while loop
	} //end of checkHom()

	public static void main(String[] args) throws LimitExceededException {

		String dataFileN = args[0], queryFileN = args[1], viewFileN = args[2];
		getQueryAnsGrViews demain = new getQueryAnsGrViews(dataFileN, queryFileN, viewFileN);

		demain.run();
	}

}

